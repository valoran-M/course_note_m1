---
jupytext:
  text_representation:
    extension: .md
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.15.2
kernelspec:
  display_name: SageMath 10.1
  language: sage
  name: sagemath
---

# Assignment

## [Access to the software and download of the assignment](../README.md)

For this week, the assignment will be essentially empty. Using the git
repository will mainly be a convenient way for you to save and
transfer your work, and for us to review it.

## Instructions

All non-trivial code must be in the [moncode.py](moncode.py) file. If
it becomes too long, you can create other files, mentioning them in
the mentioning them in the report.

Any function must:
- be documented  
  the documentation must include examples and a quick estimate
  of the *algorithmic complexity* of the function;
- be tested  
  see the example provided for how to write the tests as
  doctests;
- use wherever possible 
  [annotations of type](https://docs.python.org/3/library/typing.html).

You should have checked your code with static analysers such as
`pyflakes` or `mypy`.

In addition, you must keep a concise report up to date along the way.

## Getting started

See the files [moncode.py](moncode.py) and the report skeleton in the
[README.md](README.md).

Import the objects defined in `moncode.py` and reload them
automatically when changes are made:

```{code-cell} ipython3
%load_ext autoreload
%autoreload 2
from moncode import *
```

Use:

```{code-cell} ipython3
response("As-tu faim")
```

Consultation of the documentation:

```{code-cell} ipython3
response?
```

Static checks:

```{code-cell} ipython3
!pyflakes moncode.py
```

```{code-cell} ipython3
!mypy moncode.py
```

Launching the tests:

```{code-cell} ipython3
!sage -t moncode.py
```

## Indications

To use Sage objects in `moncode.py`, e.g. for type annotations, you
need to import them:

``` python
from sage.all import matrix, GF  # type:ignore
```

## Gauß elimination

Implement Gauß's algorithm for computing the row echelon form of a
matrix with coefficients in a field:

``` python
def reduced_echelon_form(m: matrix) -> matrix:
    """
    Returns the matrix `m` put in step form 
    “""
```

What is the complexity of your implementation? 

:::{note}

Here and in latter complexity analyses, state explicitly your
computation model: how do you measure the size of the input? What are
the elementary operations? Justify your analysis.

:::

## Membership testing for a vector subspace

Let `V=(v_i)_i` be a list of vectors. We wish to determine whether a
vector `w` is in the vector subspace generated by `(v_i)_i`.

Implement a function:

``` python
def subspace_membership(V, w):
    """
    Test whether `w` is generated by the vectors in `V`.
    """
```

You will use the `reduced_echelon_form` function.

Would it be enough to have a matrix in echelon form?

What is the complexity of your implementation?

## Computation of a base of the sum of two vector subspaces

Let $U$ and $V$ be two subspaces of some finite dimensional vector
space $W$, each given by a basis expressed in the canonical basis of
$W$. Implement an algorithm that computes a basis of the sum $U+V$ of
these two subspaces.

What is the complexity of your implementation?

```{code-cell} ipython3
K = GF(5)
M = matrix(K, [[0,0,3,1,4], [3,1,4,2,1], [4,3,2,1,3], [1, 2, 3, 4, 5]])
M
```

```{code-cell} ipython3
reduced_echelon_form(M)
M
```

```{code-cell} ipython3
M = matrix(QQ, [[0,0,3,1,4], [3,1,4,2,1], [4,3,2,1,3]])
reduced_echelon_form(M)
```

```{code-cell} ipython3
M = matrix(K, [[0,0,3,1,4], [3,1,4,2,1], [4,3,2,1,3]])
subspace_membership(M,[1, 1, -2])
```

```{code-cell} ipython3

```
