
from sage.all import matrix, vector, GF

def response(question: str) -> int:
    """
    Renvoie 42, pour toute question

    EXAMPLES::

        sage: response("Quelle est la réponse à ... et le reste?")
        42

    Complexité: `O(1)`
    """
    return 42

def reduced_echelon_form(m: matrix) -> matrix:
    """

    EXAMPLES::
        sage: reduced_echelon_form(matrix(GF(5), [[0,0,3,1,4], [3,1,4,2,1], [4,3,2,1,3]]))
        [3 1 4 2 1]
        [0 0 3 1 4]
        [0 0 0 0 0]
        
    Complexité: `O(n * m)`, n nombre de colones et m le nombre de lignes de la matrice m

    La boucle principal va itéré sur les colones (la deuxième condition est pour éviter de dépasser le nombre de ligne)
    Dans cette boucle principal on a deux boucle principal qui peuvent au plus parcours chaques éléments d'une ligne
    donc on fait O(2m) = O(m) itération à chaques itération de la boucle principale
    
    On part du principe que les opération sur la matrice se font en O(1) ce qui est faux en pratique.
    """
    i = 0
    j = 0
    while j < m.ncols() and i < m.nrows():
        # get first line with an element != 0 in the j column
        l = -1
        for k in range(i, m.nrows()):
            if m[k][j] != 0:
                l = k
                break

        if l != -1:
            m[i], m[l] = m[l], m[i]
            for k in range(i + 1, m.nrows()):
                if m[k][j] != 0:
                    m[k] = m[k] * m[i][j] - m[i] * m[k][j]
            i += 1
        j += 1
    return m

def subspace_membership(V, w):
    """
    Test whether `w` is generated by the vectors in `V`.

    EXAMPLES::
        sage: subspace_membership(matrix(GF(5), [[0,0,3,1,4], [3,1,4,2,1], [4,3,2,1,3]]), [1, 1, -2]) 
        True
    
    Complexité: `O(n * m)`, n nombre de colones et m le nombre de lignes da la matrice V
    
    La première boucle for est là pour initialiser la matrice à écheloné (O(n)).
    
    La deuxième boucle for va parcours toute les lignes O(m) de la matrice écheloné
    Dans cette boucle on à une boucle qui peut parcourire toute la ligne de W (sauf la dernière colone)
    donc O(n) itération donc on a bien O(n * m) itération
    
    On assume que toute opération sur la matrice et que reduced_echelon_form a une comlexité constante.
    """
    if V.nrows() < len(w):
        return False
    W = []
    for i in range(V.nrows()):
        if i >= len(w):
            W.append(list(V[i]) + [0])
        else:
            W.append(list(V[i]) + [w[i]])
    W = matrix(W)
    W = reduced_echelon_form(W)

    for row in W:
        l = len(row)
        if row[l-1] != 0:
            for c in row[0:l-1]:
                if c != 0:
                    break
            else:
                return False
    return True


def add_subspace(V, W):
    """
    Return the base of the sum of `V` and `W`

    EXEMPLES::
        sage: add_subspace([[1, 0, 0], [0, 1, 0]], [[0, 0, 1]])
        [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
        
    Complexité: `O(|W|)`
    
    En assumant que subspace_membership à une complexité constante il est facile de voir que la boucle fait bien
    |W| itération.
    """
    M = matrix(V)
    B = V
    for w in W:
        if not subspace_membership(M, w):
            B.append(w)
    return B

