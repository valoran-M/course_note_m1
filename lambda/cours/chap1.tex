\section{Presentation}

  \begin{itemize}
    \item 1935 (a theory of computable functions)

      Alonzo Church, attempt at formalizing computation
  \end{itemize}

  Functions:
  \begin{itemize}
    \item maths : $f : A \to B$ is a set of pairs
    \item programming : instruction to compute an output
  \end{itemize}

  \subsection{Definitions}

  We can define the set of $\lambda$-terms ($\Lambda$) with a grammar:
  \begin{align*}
    \Lambda :=&\; x, y, z ...         & (\text{variable}) \\
             |&\; \lambda. \Lambda    & (\text{functions}) \\
             |&\; \Lambda\; \Lambda   & (\text{application})
  \end{align*}

  The application is left associative: $(l_1\; l_2)\; l_3$.

  \paragraph{Notations} We can define some notations to simplify the syntax :

  \begin{center}
  \begin{tabular}{ c|c }
    Real $\lambda$-term & notations \\
    \hline
    $\lambda x_1.(\ldots(\lambda x_n. t)\ldots)$ & $\lambda x_1 \ldots
    \lambda x_n. t$ \\
    $(\ldots (t\; u_1)\ldots)$ & $t\;u_1 \ldots u_n$ \\
    $t\; u_1\; \ldots_; u_n$ & $t\; \vec{u}$ with $\vec u = u_1\; \ldots\; u_n$
  \end{tabular}
  \end{center}

  \exam We can define this $\lambda$-term:

  \begin{itemize}
    \item Identity : $I = \lambda x.\; x$
    \item Constant generator: $C_c = \lambda x.\; c$
    \item Distribution : $\lambda x\; y\; z.\; (x\;z)\; (y\;z)$
    \item What ? : $\delta = \lambda x.\;x\;x$
    \item $A = \lambda x\;y.\; y(x\;x\;y)$
    \item Fix point : $\Theta = A A$ 
  \end{itemize}


  \paragraph{Curryfication} Functions are curryfied (Haskell Curry)

  They are no cartesian product in the $\lambda$-calculus. So we can define :

  \begin{center}
  \begin{tabular}{l l l}
    $\bullet$ A function: & $(x, y)\mapsto t$ & $\lambda x\;y.\; t$ \\
    $\bullet$ An application & $f(x, y)$ & $f\; x\; y$
  \end{tabular}
  \end{center}

